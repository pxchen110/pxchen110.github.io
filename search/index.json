[{"content":"海報英文有 YIYI 和 A one and A two\u0026hellip; 的註解 這是一個喜宴開頭喪禮結尾，由一家人的生活片段交疊而成的電影，時空背景設定在沒有智慧型手機的台北，也是我尚未出生的時代，所以電影裡的台北景色對我來說都很新奇: 麥當勞內用區、誠品咖啡廳、或是圓山大飯店的宴會廳，帶有微顆粒感的畫質讓電影更吸引人。\n人物與課題 電影裡的一家四口，雖然戲份佔比不一，但如導演所說，在不同年紀看，都能在某位角色身上映射出相似的課題與身影\n媽媽希望透過信仰的力量，讓奶奶早日醒來，但在希望來臨前、一成不變的光景讓她感到無力，對現況的失望被她歸咎於自己在都市內無法堅定信仰，於是亦然決定到山上進修。 我本身的家庭背景也有一定程度的信仰，所以能理解她想透過祈禱來安定內心的想法，但在事與願違下，我或許會選擇一邊祈禱一邊接納現實、尋求另外的方法努力（理性層面是這樣想），而非選擇逃避。\n爸爸在理想與現實衝突下，聽到了來自內心的反抗，並試圖逃離功成名就，面對舊情人不解當年的分手，他雲淡風輕的說出當時的感受\n考上電機系後，我爸爸很開心，我媽媽很開心，妳也很開心，只有我不開心，我只感到悲哀\n最後他仍為家人責任妥協於現實、成為背道而馳的自己，面對商場的唯利主義，真誠的心一次次被澆熄與欺騙。\n電影裡當他在日本面對不告而別的舊情人、以及同事不重視誠信的態度，頓時跌入失望的谷底，和滿心期待的啟航畫面呈現強烈對比。\n大女兒是和我年齡最接近的角色，而生活給予她兩件歷練使她成長：沒倒垃圾與奶奶昏迷的愧疚感，以及在友情與懞懂愛情間拉扯的灼烈罪惡感，電影裡小莉的質問使她頓時心虛細語，午夜時分無法入眠。\n這些沒有回應的、無疾而終的經歷在她生命裡畫上幾道痕跡，最終趴在奶奶腿上、一幅歲月靜好的稀釋這些成長痛。\n小兒子對我來說是一個的小屁孩（誤，他帶有童真的眼光，讓本應圓滑的世俗稜角變得更為單純有創造力，像是他拿著底片相機拍著\u0026quot;別人看不見的另外一面\u0026quot;、試圖記錄吵醒人的蚊子身影，這些行為讓人不自覺露出微笑。\n只可惜現在的我已是接近訓導主任的心靈，面對童心未泯的事物，常帶著過於世俗的眼神去審視甚至曲解，或許我們應該喚起內心沉睡的小孩來看待事物。最後在喪禮上，導演也透過他用較為童真的眼光去解讀死亡這件事。\n他們都說你走了，但我不明白你去哪裡，或許有一天我們還會再見面，到時你再帶我去看你去了哪裡\n即使每個人都各自面臨生活課題與情緒，但仍踏入家門同坐一桌吃飯，聊著不著邊際試圖關心對方的話題，家人之間既疏離又接近得情感，或許也是最難能可貴的關係。\n印象深刻的場景一: 跟奶奶說話 奶奶的房間就像是告解室，讓觀眾有機會傾聽角色內心獨白的場景，因為沒有人回應，就像爸爸坦白地說道\n其實這樣自言自語對我來說蠻難得，我這樣講你不要生氣，我覺得，好像在拜拜。除了不知道對方是不是聽得到之外，對我自己講的話是不是真心的，好像也沒什麼把握\n那裏是角色內心世界的延伸，和與外界互動的所武裝起來的堅硬外層相比，人物更加深情、但相反也更加沈默 \u0026ldquo;即使悲傷也無人應答\u0026rdquo; 想起自己也曾躺在床上，手握護身符，多次向神訴說我的心情、祈求一個應許，以及一個不可能的回應，雖然生活物理上一成不變，但我想這股聲音中就能被聽見，並自我寬慰，比起悶在心裡會更好受一點。\n印象深刻的場景二：台日兩地穿插的約會場景 電影以交叉蒙太奇的手法，呈現兩代人在情感約會上的重疊相似性，一邊是遠在東京街頭漫步的中年男女，另一邊是在信義區初次相約的年輕男女，互相靠近的心與牽起的手，情感展開的不言而喻。\n印象深刻的場景三：拍下別人看不見的另一面 我們是不是只能知道一半的事情啊？我們只能看到前面，看不到後面，這樣不就有一半的事情看不到了嗎？\n童真的眼光總能犀利點出長大成人後被遺忘的真理，我們常因片面的善惡去評判對方的言行舉止，更可能忽略人(包含自己)擁有多個面向的事實，以詼諧地拍攝物理上看不見的那面，來激發我們沉思。\n最後\u0026hellip; 這部電影雖無驚險刺激的場景，楊德昌導演透過仔細雕琢的劇本，呈現出平淡而飽滿的故事，那些虛構角色身上、以最大公約的方式交疊了世間許多課題，也成功引起廣大共鳴，不用旁白敘述而用動作台詞，就能讓我們聯想這些角色的性格與境遇，是很高明的成就。導演先前拍攝的牯嶺街少年殺人事件，也同樣在3個小時的有限框架下，以精心設計的鏡頭故事，刻畫出有血有肉的時代與角色輪廓，很容易與之共情。\n參考資料（劇照來源） https://plaza.openmuseum.tw\nhttps://blog.addmusic.tw/2019/01/17/金獎剪接師陳博文：「好的剪接師，要對音樂有敏/s_23ff5b50ed7c50b7235542b67cc577c5b2302e81e52c007f9219e21ecef04ef5_1546932553956_imagelab-nownews-com_/\nhttps://www.ettoday.net/dalemon/post/38955\n","date":"2024-02-26T00:00:00Z","image":"https://pxchen110.github.io/post/movie-yiyi/20240226_img0.webp","permalink":"https://pxchen110.github.io/p/%E6%A5%8A%E5%BE%B7%E6%98%8C-%E4%B8%80%E4%B8%80-%E8%A7%80%E5%BE%8C%E6%84%9F/","title":"楊德昌《 一一 》觀後感"},{"content":"Background photo by Artturi Jalli on Unsplash\n撰寫程式專案時，常需要在父進程下創建子進程進行支線任務，例如在shell script(.sh)中，會在 linux command 的基礎下，包含 python script, R script 的執行，透過串聯輸出\\輸入檔案的方式，產生目標內容。\n同理我們也能在以 python 做為父進程的情況下，以 subprocess 模組協助執行外部指令(子進程)、串接資料輸出\\輸入的管道、並取得返回值，本文將介紹 subprocess 模組管理子進程的方法與程式碼。\nPart1: subprocess 套件引入 subprocess 為 Python 內建模組，引入即可使用\n1 2 import subprocess from subprocess import PIPE, Popen Part2: 基本函數: run() and Popen() subprocess 啟動子進程的方式有兩種 subprocess.run() 和 subprocess.Popen 其中run()在大部分情況下都可使用，Popen() 則使用於更進階的底層操作 兩函數的基本參數都一樣，下面以 run() 來做參數介紹:\nsubprocess.run() 外部指令的參數有兩種輸入方式，但建議以list形式輸入: 可以使用 shlex 套件協助將指令 string 切分成 list 注意: shell = True 代表允許系統調用shell執行，如同讓主機門戶大開、容易發生 shell injection 的資安風險，請盡量少用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # in linux shell ln -s # in python subprocess run ## method1: input as list (recommend!) ## 徒手拆分成list subprocess.run([\u0026#39;ln\u0026#39;, \u0026#39;-s\u0026#39;]) ## 用shlex協助拆分成list cmd_split = shlex.split(\u0026#39;ln -s\u0026#39;) subprocess.run(cmd_split) ## method2: input as string, with shell = True subprocess.run(\u0026#39;ln -s\u0026#39;, shell = True) default 情況下，run() 執行無誤 (returncode = 0) 後會返回 subprocess.CompletedProcess 的實例並印出結果；如果想查看返回狀況，可加上check = True ， 當 returncode != 0 會抛出 CalledProcessError default 情況下，run() 將結果直接印出，若想抓取輸出並存成變數，可使用 capture_output = True default 輸出形式為 bytes，可用 text = True 來更改輸出形式，透過下面例子來比較: 1 2 3 4 5 6 7 a = subprocess.run([\u0026#39;pwd\u0026#39;], capture_output = True) print(a.stdout) \u0026gt; b\u0026#39;/current/working/directory\\n\u0026#39; a = subprocess.run([\u0026#39;pwd\u0026#39;], capture_output = True, text = True) print(a.stdout) \u0026gt; /current/working/directory subprocess.Popen() 大部分的參數跟 run() 相同，特別的是只有 Popen() 可使用 PIPE 在串聯子進程間的 stdout, stdin, stderr，並搭配 communicate()防止死瑣，詳細內容在Part3 注意: run()不能使用 PIPE 和 communicate()\nPart3: 以 PIPE 串聯進程間的輸入\\ 輸出 PIPE 觀念相當於 linux 裡的 piping |，可減少中間檔案儲存的冗餘。 下面的例子利用 PIPE 將第一個子進程的輸出，當作第二個子進程的輸入\n1 2 cmd1 = subprocess.Popen([\u0026#39;pwd\u0026#39;], stdout = PIPE) subprocess.Popen([\u0026#39;ls\u0026#39;, \u0026#39;-alh\u0026#39;], stdin = cmd1.stdout) PIPE 的實用程度高，但當管道內暫存的資料量過大，會造成子進程卡住，永遠無法結束(稱作死瑣)，使用 communicate() 可即時讀取 PIPE 內容:\n1 2 3 e = subprocess.Popen([\u0026#39;pwd\u0026#39;], stdout = PIPE, stdin = PIPE, text = True) out, err = e.communicate() print(out) 另外也可將 PIPE 的輸出存進檔案，解決死瑣問題\n1 2 f = open(\u0026#39;save_stdout.txt\u0026#39;, \u0026#39;w\u0026#39;) subprocess.Popen([\u0026#39;pwd\u0026#39;], stdout = f, text = True) Part4: 實例應用 Example1: 我想檢查幾份log檔是否有回報錯誤訊息，利用 PIPE 加上 communicate() 將子進程 grep 到的內容存進 out 變數、並判斷是否有錯誤訊息\n1 2 3 4 5 6 7 8 9 10 11 12 13 import shlex import subprocess from subprocess import PIPE, Popen logs = [\u0026#39;log.1\u0026#39;, \u0026#39;log.2\u0026#39;] for i in logs: cmd = shlex.split(\u0026#39;grep \u0026#34;terminated with an error exit status\u0026#34; {}\u0026#39;.format(i)) p = subprocess.Popen(cmd, stdout = PIPE, text = True) out,err = p.communicate() if out: ## NOT NULL sys.exit(\u0026#39;Error occured, please refer to {} for more detail\u0026#39;.format(i)) Example2: 現在有一份vcf原始檔，需要先以bio-tool(using Singularity)做格式轉換，再用python做資料篩選，但我不想產生轉換格式的中間檔，於是寫了以下 python script，以原始vcf做input，先開一個子進程處理vcf，以PIPE儲存輸出，存進 pyton 變數並作後續篩選\n1 2 3 4 5 6 7 8 9 10 11 12 import sys import shlex import subprocess from subprocess import PIPE, Popen origin_vcf = sys.argv[1] cmds = shlex.split(\u0026#39;singularity exec vcflib_1.0.0-rc2.sif vcf2tsv {}\u0026#39;.format(origin_vcf)) input_vcf = subprocess.run(cmds, stdout = PIPE).stdout.decode(\u0026#39;utf-8\u0026#39;).splitlines() for lines in input_vcf: #post-filtering in python 參考資料 https://docs.python.org/zh-tw/3/library/subprocess.html# https://www.aikaiyuan.com/4705.html\n","date":"2024-02-22T00:00:00Z","image":"https://pxchen110.github.io/post/python-subprocess/20240222_img1.jpg","permalink":"https://pxchen110.github.io/p/python%E7%B3%BB%E5%88%97subprocess%E6%A8%A1%E7%B5%84%E7%AE%A1%E7%90%86%E5%AD%90%E9%80%B2%E7%A8%8B/","title":"Python系列：subprocess模組管理子進程"},{"content":"Background photo by Artturi Jalli on Unsplash\n撰寫python script時，變數內容若能隨使用者彈性更改，可提升程式實用性；本文介紹三種常用的引入外部參數模組: sys, argparse, 以及 click，文章將介紹模組/套件的使用方式，撰寫相同輸出的實例，並分析優缺點以供讀者參考。\nsys 模組 sys 屬於 python 內建模組，其下的 sys.argv[index] 是最基本的引入方式。\nsys.argv 的運行方式，是把bash command line 中輸入的指令存成一個list，並引入對應index的內容名稱。\nIndex 對照說明 假設撰寫名為 test.py 的 script:\n1 2 3 4 5 6 import sys input_var1 = sys.argv[1] print(\u0026#34;sys index 0 : \u0026#34; + sys.argv[0]) print(\u0026#34;sys index 1 : \u0026#34; + input_var1) 在 linux bash 執行 python script :\n1 python3 test.py apple 注意: sys 會將 script 名稱視為 sys.argv[0] 也就是index 0 不能使用，而外部參數的 index 會從 1 開始\n綜合上述觀念，bash 輸出:\n1 2 sys index 0 : test.py sys index 1 : apple 實例 撰寫名為 test.py 的 script:\n1 2 3 4 5 6 import sys fruit = sys.argv[1] price = sys.argv[2] print(\u0026#34;The price of \u0026#34; + fruit + \u0026#34; is \u0026#34; + price) bash 輸入參數 python3 test.py apple 20 得到\n1 The price of apple is 20 Comments sys 方式多用於測試階段，或是簡單的個人專案上，若需要引入多個參數，或是有協作專案的需求，sys會面臨以下缺點:\nindex 引入很看重順序，參數太多增加錯誤機會 且無法為下一個使用者解釋輸入參數的內容，降低推廣性 接下來要介紹的兩個模組，都是針對不同參數給予特定名稱，並說明參數要求，提高script的實用性。\nargparse 模組 argparse 同屬於 python 內建模組，用於命令列剖析\n引入模組 引入模組後先創建 ArgumentParser 物件以及設定參數\n1 2 import argparse parser = argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None) prog: program 名稱，不指定寫 None，default 會帶入 python script 名稱 usage: 告知使用者說應該怎麼使用 program，default 會帶入 script 名稱加上所有參數 description: 一段文字說明程式功能 epilog: 添加在 --help 訊息後的補充文字\n例子:\n1 2 3 4 5 6 ## 撰寫 test.py import argparse parser = argparse.ArgumentParser(prog = None, usage = None, description = \u0026#39;this is description\u0026#39;, epilog = \u0026#39;this is eliog\u0026#39;) 1 2 3 4 5 6 7 8 9 10 ## 在 bash 輸入 python3 test.py --help 會產生以下內容 usage: test.py [-h] --anno ANNO this is description options: -h, --help show this help message and exit this is eliog 添加參數名稱 1 2 parser.add_argument(\u0026#34;--anno\u0026#34;, required = T, help = \u0026#34;required arguments\u0026#34;) parser.add_argument(\u0026#34;--input\u0026#34;, default =\u0026#34;none\u0026#34;) -a / --anno 為自定義的參數flag，以將參數引入特殊變數內 required 執行script 必須要有的參數，default = False default 當使用者沒給此項參數，則引入預先設定的default值 help 針對參數的說明文字，使用 --help 後會顯示\n將參數後的內容引入變數 以 args.parameter_flag 的形式引入特定參數下的內容\n1 2 args = parser.parse_args() a = str(args.anno) 實例 撰寫名為 test.py 的 script:\n1 2 3 4 5 6 7 8 import argparse parser = argparse.ArgumentParser(description = \u0026#34;print input friut type and their price\u0026#34;) parser.add_argument(\u0026#39;-f\u0026#39;, \u0026#39;--fruit\u0026#39;, required=True, help= \u0026#34;name of fruit\u0026#34;) parser.add_argument(\u0026#39;-p\u0026#39;, \u0026#39;--price\u0026#39;, default = 20, help = \u0026#34;price of item\u0026#34;) args = parser.parse_args() print(\u0026#34;The price of \u0026#34; + args.fruit + \u0026#34; is \u0026#34; + args.price) bash 輸入 python3 test.py --help 查看訊息\n1 2 3 4 5 6 7 8 usage: test.py [-h] -f FRUIT [-p PRICE] print input friut type and their price options: -h, --help show this help message and exit -f FRUIT, --fruit FRUIT name of fruit -p PRICE, --price PRICE price of item bash 輸入參數 python3 test.py --fruit apple --price 20 得到\n1 The price of apple is 20 Comments argparse 模組提升參數引入的複雜性與數量，增加在真實世界的使用機會；但複雜的步驟轉換（建立物件 \u0026gt; add_args \u0026gt; parse_args）讓人頭昏眼花，若能有更簡單的參數設定機制，可以減低程式撰寫的難易度\nclick 套件 click 官網以 creating beautiful command line interfaces 形容套件的核心功能\n下載並引入套件後，只需利用 @click.command 和 @click_option 即可產生和argparse等價的結果\n實例 1 2 3 4 5 6 7 8 9 10 import click @click.command @click.option(\u0026#39;-f\u0026#39;, \u0026#39;--fruit\u0026#39;,\u0026#39;fruit\u0026#39;, required=True, help= \u0026#34;name of fruit\u0026#34;) @click.option(\u0026#39;-p\u0026#39;, \u0026#39;--price\u0026#39;, \u0026#39;price\u0026#39;, default = 20, help = \u0026#34;price of item\u0026#34;) def main(fruit, price): print(\u0026#34;The price of \u0026#34; + fruit + \u0026#34; is \u0026#34; + str(price)) if __name__ == \u0026#39;__main__\u0026#39;: main() bash 輸入參數 python3 test.py --fruit apple --price 20 得到相同console:\n1 The price of apple is 20 Comments 和 argparse 相比 click 語法更加簡潔，許多參數都相容，推薦新手可以直接使用click建立參數指令，但請注意 python 版本相容性，詳細可參考官網說明。\n參考資料 https://docs.python.org/zh-tw/3/library/sys.html#sys.argv https://docs.python.org/zh-tw/3/howto/argparse.html https://click.palletsprojects.com/en/8.1.x/ https://myapollo.com.tw/blog/python-click/\n","date":"2024-02-21T00:00:00Z","image":"https://pxchen110.github.io/post/python-argument-input/20240221_img1.jpg","permalink":"https://pxchen110.github.io/p/python%E7%B3%BB%E5%88%97-%E4%B8%89%E7%A8%AE%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E5%8F%83%E6%95%B8%E7%9A%84%E6%96%B9%E6%B3%95/","title":"Python系列： 三種引入外部參數的方法"},{"content":"Background photo by Brett Jordan on Unsplash\n在信箱收件夾，不乏看到許多自動寄出的信件，像是來自 slurm job 通知分析狀態的信，以及訂閱內容的自動通知等。自動寄信不僅節省人力操作，也可廣發信件增加傳播效率。今天就要介紹如何用python實現自動寄信\nPart1: SMTP協定介紹 通訊協定，是協助資訊在不同軟硬體之間傳輸的方式，例如使用相同IP的兩台電腦，可以突破主機限制互相通訊。網際網路中，常用的通訊協定包含TCP/IP, HTTPS(TLS/SSL加密)，以及本文要使用的SMTP協定。 SMTP全名為簡易郵件傳輸通訊協定 (Simple Mail Transfer Protocol)，是透過網路在電腦與伺服器之間接收與傳送電子郵件的通訊方式。只要知道服務廠商的smtp, port, 並提供一個寄件帳號，就可以自動\\廣發信件給多名收件人。\n常見的廠商與smtp伺服器：\ngmail: smtp.gmail.com outlook: smtp-mail.outlook.com 常見的連接埠比較(內容節錄自cloudflare網站) :\n連接埠 25 最常用於 SMTP 伺服器之間的連線。如今，用於終端使用者網路的防火牆通常會封鎖該連接埠，因為垃圾郵件發送者嘗試濫用它來傳送大量垃圾郵件。\n連接埠 465 曾經專供具有安全通訊端層 (SSL) 加密的 SMTP 使用。但是 SSL 已被 Transport Layer Security (TLS) 取代，因此現代電子郵件系統不再使用該連接埠。它只存在於舊版（過時的）系統中。\n連接埠 587 現在是電子郵件提交的預設連接埠。透過此連接埠進行的 SMTP 通訊使用 TLS 加密。\nPart2: 撰寫python程式 python 提供 smtplib 模組來協助 smtp 封裝信息並傳輸給目標端。由於\nstep0: 引入套件和開啟google mail 權限 1 import smtplib 除了基本模組，常搭配擴充電子郵件標準套件，來處理內文部分\n1 2 from email.mime.multipart import MIMEMultipart #email內容載體 from email.mime.text import MIMEText #製作郵件內文 若要在gmail使用smtplib，需要到 google 帳戶的安全性頁面 完成帳戶密碼設定(下圖紅框標示處)\nstep1: 設定帳戶資訊 1 2 3 4 5 6 7 MAIL_USER = \u0026#34;from_who_user_@gmail...\u0026#34; #寄件者email帳號 MAIL_PASSWD = \u0026#34;......\u0026#34; #寄件者email密碼 FROM_ADDRESS = MAIL_USER #和寄件者相同 # 郵件平台的主機 port (這裡使用 gmail smtp 伺服器) MAIL_SMTP = \u0026#34;smtp.gmail.com\u0026#34; MAIL_PORT = 587 #安全加密port \u0026#34;587\u0026#34; step2: 撰寫郵件內容與寄件人 1 2 to_address = \u0026#34;to_who_@gmail...\u0026#34; #收件者email帳號 body_content = \u0026#34;\u0026#34; #輸入郵件內文 step3: 以擴充電子郵件標準來組合 email 結構 1 2 3 4 5 6 mail = MIMEMultipart() mail[\u0026#39;From\u0026#39;] = FROM_ADDRESS #寄件者 mail[\u0026#39;Subject\u0026#39;] = \u0026#34;the subject\u0026#34; #主旨 mail[\u0026#39;To\u0026#39;] = to_address #收件者 mail.attach(MIMEText(body_content)) #以attach方式貼上內文 step4: 設定smtp伺服器並寄信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 smtpserver = smtplib.SMTP(MAIL_SMTP, MAIL_PORT) # 發出「Hello」訊息，以在用戶端和伺服器之間建立SMTP連線 smtpserver.ehlo() # TLS加密：延伸保護 SMTP 階段作業 smtpserver.starttls() # 登入寄件人郵件系統 smtpserver.login(MAIL_USER. MAIL_PASSWD) # 將step3產生的信件內容轉成string並寫入 smtpserver.sendmail(FROM_ADDRESS, to_address, mail.as_string()) # 結束系統連線 server.quit() Part3: 完整script \u0026amp; 成果展示 附上完整的 python script 注意: 由於使用個人主機測試，才敢將信箱帳密直接輸入在command line、由 sys 存取，若在公用主機請注意資安考量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/env python3 import os import sys import smtplib from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText mail_user = sys.argv[1] mail_passwd = sys.argv[2] from_address = mail_user mail_smtp = \u0026#34;smtp.gmail.com\u0026#34; mail_port = 587 to_address = sys.argv[3] body_content = \u0026#34;\u0026#34;\u0026#34; This is the auto-send email test \u0026#34;\u0026#34;\u0026#34; mail = MIMEMultipart() mail[\u0026#39;From\u0026#39;] = mail_user mail[\u0026#39;To\u0026#39;] = to_address mail[\u0026#39;Subject\u0026#39;] = \u0026#34;Test for smtp email-sender\u0026#34; mail.attach(MIMEText(body_content)) server = smtplib.SMTP(mail_smtp, mail_port) server.ehlo() server.starttls() server.login(mail_user, mail_passwd) server.sendmail(mail_user, to_address, mail.as_string()) server.quit() 到收件者的信箱查看，成功收到如下圖的信件\n參考資料 https://aws.amazon.com/tw/what-is/smtp/ https://www.cloudflare.com/zh-tw/learning/email-security/what-is-smtp/\n","date":"2024-02-15T00:00:00Z","image":"https://pxchen110.github.io/post/python-smtplib/20240215_img1.jpg","permalink":"https://pxchen110.github.io/p/python%E7%B3%BB%E5%88%97-smtplib-%E6%A8%A1%E7%B5%84%E5%AF%A6%E7%8F%BE%E8%87%AA%E5%8B%95%E5%AF%84%E4%BF%A1/","title":"Python系列： smtplib 模組實現自動寄信"},{"content":"參考資料來源：udemy 課程\n從上次練習從零創造網頁佈局後，發現自己的技巧和美感都有待進步，決定跟著udemy課程的實作項目:搭建拼多多網站首頁，來學習真實網站有哪些常用的佈局和技巧。\n學習流程：將影片要仿寫的部份截圖-\u0026gt;自己寫看看-\u0026gt;觀看課程影片比對老師和我的作法差異-\u0026gt;改善程式-\u0026gt;完成！\n大致的切版規劃: 切版成三區塊，以及一個固定於網頁左下方的qrcode，在html會分成四個\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;撰寫\nheader+nav(嚴格來說只有navigation bar) body(以相同模板套用內容並垂直排列) footer(下方聯絡資訊等樣式) qrcode banner Header+nav section 切版設計: html元素:\n圖片和nav文字都是 \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; 元素 css樣式重點:\n網頁滑動仍固定於上方: 1 2 3 4 position: fixed; /*固定在最上面*/ top: 0; /*定位*/ left: 0; /*定位*/ z-index: 999; /*滑動時不會被上來的div蓋住*/ nav的div以flex呈現水平排列，以border作為間隔，並清除尾端div的border 1 2 display: flex; /*將div以flex規劃排列方式，呈現清單*/ flex-direction: row; nav 下面的小div以border作為間隔 在倒數個div加上class name(.g-header-list-re)，練習以+方式清除最後一個div元素的border 1 2 3 4 5 border-right: 1px solid gray; .g-header-list-re + div { /*清除最後一個元素的border*/ border-right: none; } body section 切版設計: html元素:\n由於區塊模板相似，做好一個候可以重複套用添加內容 一個區塊以div包覆，下面分三個小div操作 最上div面用 \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; 和 \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; 放置文字與連結點選 中間div放大圖片 下方div包含三個小div，放置圖片，文字等商品資訊 css樣式重點:\nbody整體以header做父元素定位，並做水平置中 body寬度以view point為單位設定，使其可依照視窗縮放比例 區塊模板以flex呈垂直排列 1 2 3 4 5 6 7 8 9 10 11 position: absolute; top: 40%; left: 50%; /*搭配margin-left: -(width/2)做水平置中*/ overflow: hidden; display: flex; flex-direction: column; gap: 50px; margin-left: -40vw; /*寬度的一半做水平置中*/ width: 80vw; 區塊模版最上方的\u0026lt;p\u0026gt;和\u0026lt;a\u0026gt; 分別以 float: left; float: right; 浮動 區塊模板下方再套用flex呈水平排列 1 2 3 display: flex; flex-direction: row; gap: 10px; footer section 切版設計: html元素:\n上方div內有兩個小div，分別放置qrcode跟聯絡資訊 下方div跟header的nav清單相似，但以list寫法呈現 css樣式重點:\nfooter整體以body做父元素定位 使用預先知道得body total height作為top距離，讓footer銜接在body下方 1 2 3 4 5 6 position:absolute; top: 3000px; /*不太好得做法，以body為父元素，body height為top距離*/ padding-top: 60px; width:100vw; /*可依視窗大小縮放的寬度單位*/ height:300px; background-color: lightgray; 上方div內的兩個小div以float:left;做浮動 左側div以flex讓內部三個div呈水平排列，同時設定跟右側div相同的高度 右側div主要調整的是p元素的間隔，高寬，以及與左側div的距離，並以border做區隔 1 2 3 4 5 /*左側div css*/ display: flex; /*flex方式排列qrcodes*/ flex-direction: row; gap: 10px; height: 240px; /*讓img+text總高和右側聯絡資訊一樣*/ 1 2 3 4 5 6 7 8 /*右側div css*/ text-align: left; border-left: 1px solid black; margin-left: 15px; margin-bottom: 20px; padding-left: 45px; line-height: 30px; font-size: 20px; 下方div(.g-footer-list)的list以更改display:inline-block;的方式呈水平排列，並保留設定元素寬度的能力 練習以last-child或first-child方式移除頭尾元素的border 1 2 3 4 5 6 .g-footer-list ul li { /*以inline-block displayed list製作清單*/ display: inline-block; /*可設長寬的元素*/ border-left: 1px solid black; margin: 0 auto; /*給予寬度的情況下，margin auto可置中*/ width: 100px; } 1 2 3 .g-footer-list li:first-child { /*remove border for the first element in the list*/ border: none; } qrcode banner html元素:\ndiv包含img和兩個小div css樣式設計:\n整體定位，以網頁為父元素，固定浮動於左下方 設定z-index浮動在body和footer上方 1 2 3 4 5 6 7 position: fixed; /*固定浮動在網頁左下方*/ bottom: 50px; left: 100px; z-index: 998; /*不被body蓋住*/ padding: 10px 30px; border: 1px solid gray; background-color: white; 先設定圖片寬度，配合left和margin-left讓圖片水平置中於div內 1 2 3 4 5 6 img { position: relative; left: 50%; margin-left: -75px; width: 150px; } 成果展示 Github 原始碼 一併附上拚多多網站連結\n檢討回顧 以上就是我得第一版網站仿寫，過程歷經許多trial and error，像是沒規劃好區塊，等寫到60%時又重新修改架構，打掉重練的狀況；也蠻常遇到加了css樣式但卻出不來的困惑。最後列出幾點我在udemy上學到的技巧，以及這一版仿寫有待改進的部分:\nnavigation bar 應該也改成list製作會比較簡單，開太多div來包感覺沒意義 footer出現在尾端的定位方式非robust，和body依賴性太高，萬一body新增內容豈不是要調整top數值? 佔滿視窗大小並依比例調整，改用100%會比100vw好，原因可以參考此網站的解釋 透過將float: left;`` float: right; 設成一個class name，當有元素需要就加上這個class是有效率的方法 同理可以新增清除浮動的class，有需要就加上 1 2 3 4 5 .clearfix::after { /*清除浮動 content: \u0026#34;\u0026#34;; display: block; clear: both; } 一開始就設定所有的a元素都移除下底線，或所有list都移除符號 ","date":"2024-02-11T00:00:00Z","image":"https://pxchen110.github.io/post/html-css-practice2/20240211_img0.png","permalink":"https://pxchen110.github.io/p/html-css%E6%88%90%E6%9E%9C%E5%B1%952%E4%BB%BF%E5%AF%AB%E6%8B%BC%E5%A4%9A%E5%A4%9A%E7%B6%B2%E7%AB%99/","title":"HTML+CSS成果展(2)：仿寫拼多多網站"},{"content":"在udemy上學了html+css的知識，光看不會進步，動手做一遍才知道不熟的地方，我寫一個標題為要來我家看貓嗎的小網頁\n切版架構 可以分成兩大區塊:\nheader section body section header section html元素: 單純地用h1做大標題\ncss樣式設計:\n整體div固定在最上方，並加上z-index讓body上滑不會蓋住它 1 2 3 4 5 6 7 position: fixed; z-index: 2; top: 0; border: 1px solid lightblue; background-color: lightblue; width: 100%; /*fill all broswer*/ height: 50px; body section body部分以 display:flex 排列，並添加 wrapper 讓每行可以依照視窗大小改變容器數量 每個容器包含img,固定寬度200px 加上一些文字描述，和尚未引入javascript的button，其中有添加cursor樣式以及hover的pseudo element 為了讓文字與圖片置中排列於容器內，以position: relative 定位，使用 left: 50%; margin-left:-(img_width/2); 來置中\nhtml元素:\n區塊模板相同，每個div由上到下依序為標題div、圖檔img、文字div、以及按鈕button css樣式設計:\n整體body沒有加定位樣式，因此設margin-top來預防被header遮蓋 對於內部區塊模板，以flex呈現水平排列，並設定flex-wrap來允許視窗大小改變時，div能變成多行排列 1 2 3 4 5 6 7 display: flex; flex-direction: row; flex-wrap: wrap; align-content: flex-start; margin: 50px; margin-top: 200px; /*solving position:fixed covering problem*/ width:auto; 針對區塊模板，給予寬度後設定 margin:auto 來均分左右空間，border調整圓弧形 1 2 3 4 5 margin: auto; /*share left space equally*/ border: 1px solid lightblue; border-radius: 10%; width: 300px; height: 400px; 區塊內部的按鈕，加上鼠標移上去的偽元素樣式 1 2 3 .but-class-name:hover { background-color: lightcoral; } 成果展示 Github 原始碼\n從下兩張圖比對，可以看到當螢幕尺寸改變，每行可容納的div數量也會彈性調整\n","date":"2024-02-08T00:00:00Z","image":"https://pxchen110.github.io/post/html-css-practice1/20240208_img2.png","permalink":"https://pxchen110.github.io/p/html-css%E6%88%90%E6%9E%9C%E5%B1%951%E5%8F%AF%E6%84%9B%E8%B2%93%E5%92%AA%E7%B6%B2%E7%AB%99/","title":"HTML+CSS成果展(1)：可愛貓咪網站"},{"content":"決定撰寫個人部落格後，參考許多網友的平台推薦，最終決定選擇免付費和客製化自由度高的Github，同時練習 markdown語法, git 管理部分。本篇文章記錄我建立網站的步驟和遇到的問題，避坑避雷你我有責。\n本機環境: MacOS Sonoma\nPart1: Github 創建倉庫專案 首先要創建GitHub帳號，Github是提供開發者存放專案、進行版本控制的好平台，大部分開源工具會將source code放在Github提供下載使用 選擇 Create a new repository 建立新專案，以 ${username}.github.io 來命名並以Public形式發表，初始狀態會產生一個空的reposiroty 回到本機端，以 git clone ${repository_url} 將專案載到本機端；完成後會在當前目錄找到和專案同名 ${username}.github.io 的資料夾 注意：由於之後我們會在這個資料夾下新增檔案，並推送回Github(git push)，過程牽涉authorization問題，可以先建立ssh-key 或 token 授權 Part2: 透過 npm 下載 Node.js 函式庫 Hexo 來推送管理Blog 在本機端安裝npm（Node.js的套件管理系統） 不同作業系統的安裝可參考 Node.js社群文件 我選擇透過Macport安裝： 先下載Macport 安裝 Node.js 和 npm 1 2 3 4 5 sudo port install nodejs10 sudo port -d selfupdate sudo port install npm npm -v #測試安裝是否成功 透過 npm 安裝 Hexo 並初始化，完成後會產生名為 blog 的資料夾 1 2 3 4 5 6 #install hexo (sudo) npm install hexo-cli -g # Blog initialization hexo init blog cd blog 將 blog/ 下的所有檔案複製到剛才clone回來的github repository 資料夾下，再執行npm 安裝 hexo 需要的套件 1 2 cp -R * /path/to/${username}.github.io (sudo) npm install 指令完成後將會看到以下檔案和資料夾，介紹我目前有編輯過的部分： _config.yml 是設定網站的配置檔案 theme/ 客製化主題存放的地方 source/_post/ 放置發布文章(.md)的地方 Part3: 編輯 configuration 並推回 Github 設定blog相關內容，keyword 解釋可參考官方文件。我編輯過的部分包含：\n網站標題、作者、網址： deploy 來源：特別注意 push branch，由於 Github 目前 default branch 是 main，config 內要設定 push 到 main branch 才有效，當時我沒注意順手設 master，直接讓文章與主題樣式分離\u0026hellip; repo 就貼上 ssh clone 的網址 儲存檔案後，透過以下指令推送回Github：\n1 2 3 4 hexo clean #清除靜態網頁 hexo generate # == hexo g 透過設定文件產生靜態網頁 hexo server # == hexo s 產生測試機看成果 hexo deployer # == hexo d 將內容部署到git上 注意: 執行 hexo deployer 可能遇到以下錯誤：Deployer not found: git，原因是缺少 hexo-deployer-git 套件\n透過以下指令安裝：\n1 npm install hexo-deployer-git --save 都完成後可以透過以下網址看初始成果：https://${username}.github.io\nPart4: 挑選客製化主題 有了地基就可以蓋房子啦(誤) 除了 github 提供的基本網站樣式，Hexo 網站有很多開源主題 可以下載套用，如果沒頭緒可以看別人推薦 套用主題的方法： git clone 回名為 theme 的資料夾內 到先前編輯過的 _config.yml 加上主題名稱，並依照主題的 documentation 進行操作 1 git clone ${theme_repository_url} /path/to/${username}.github.io/themes/theme_name Part5: 階段成果 我的blog 使用的是 tranquilpeak 主題，第一眼就被簡約有質感的排版吸引 (尤其是sidebar部分)，主題目前支援中文樣式及嵌入搜索引擎，但 documentation 只有英文版\nGithub Link Demo Link 目前做了基礎設定和更改背景，官方文件還有很多功能沒測試，持續摸索～\nPart6: 新增貼文 當要發布文章時，需要以markdown語法撰寫，我推薦使用hackmd 來協助在markdownm語法下完成文章，建立貼文的步驟如下：\n將當前目錄跳轉至_post內並以下方指令產生.md檔和放置圖片的同名資料夾 1 hexo new post_name 編輯 .md檔 將hackmd上的文章複製貼上即可 注意：圖片顯示需要一個確認＋三個步驟，四者缺一不可 確認 _config.yml 設定 post_asset_folder: true npm 透過以下指令安裝圖片顯示套件 (sudo) npm install https://github.com/CodeFalling/hexo-asset-image --save 將圖片放在 /_post/post_name/ 資料夾下，例如我在資料夾下放一張名為 img1.png 的圖檔 若以放在上方資料夾，.md檔內圖片只要打名稱即可，例如我只要打 ![](img1.png) 圖片就可顯示嘍！ 最後以步驟10推送回Github就完成發文了 以上就是我的第一篇文章分享，歡迎一起討論！\n","date":"2024-02-01T00:00:00Z","image":"https://pxchen110.github.io/post/hexo-blog/20240201_img5.png","permalink":"https://pxchen110.github.io/p/%E7%94%A8github-hexo%E5%BB%BA%E7%AB%8B%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC%E6%96%B9%E6%B3%95%E8%88%87%E5%95%8F%E9%A1%8C%E7%B4%80%E9%8C%84/","title":"用Github+Hexo建立個人部落格：方法與問題紀錄"}]